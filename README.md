# SelectiveRepeat

----
## 개발 배경/목표

>* Go-back-N ARQ 프로토콜은 수신자 쪽에서의 과정을 단순화 하고 있다. 수신자는 오직 하나의 변수만 관리하며 순서가 뒤바뀌어 도달한 Packet들을 보관하는 버퍼가 없이 단순히 버려질 뿐이다. 그러나 이 프로토콜은 잡음이 많은 채널에서는 매우 비효율적이다. 잡음이 있는 채널에서는 Packet이 손상될 확률이 높아지며 이는 다수의 Packet을 다시 전송하게 되는 것을 의미한다. 이 재전송으로 인해 대역폭을 소모하게 되며 전송 속도도 저하된다. 잡음이 있는 채널에 대해서는 오직 하나의 Packet이 손상되었는데 전체 N개의 Packet을 재전송하는 대신에 오로지 손상된 Packet만 다시 전송하는 방법이 있다. 이 방법이 Selective Repeat ARQ 이다. 이 프로토콜은 잡음이 있는 채널에서 효율적이지만 수신자 쪽에서의 절차가 더욱 복잡하다.

>* 이 프로토콜은 TCP 프로토콜로 이미 구현되어있지만 그렇지 않은 UDP 프로토콜로 구현함으로 이에대한 이해를 증진시킬 수 있을 것이다.


----
## 개발 구성 및 과정

>* 클라이언트(송신자)와 서버(수신자)간에 가상 데이터 Packet을 송수신함

>* UDP 프로토콜을 사용하지만 TCP 프로토콜의 재전송 방식 이론중 하나인 SelectiveRepeat을 구현하여 송수신간 데이터 오류가 생겨도 재전송이 일어나게 함

>* 0부터 9까지의 데이터를 전송하는 시뮬레이션을 작성하고 중간에 프레임이 손상되어 전송되지 못하는 상황을 상정함

>* 해당 오류 상황에서 SelectiveRepeat의 WINDOW가 버퍼들 사이에서 어떻게 움직이는지 확인함


----
## 개발 내용

>* UDP 소켓 통신하는 클라이언트와 서버를 작성하여 가상 데이터 패킷인 Integer 배열을 시간에 맞춰 전송함

>* 아래 그림과 같이 3번 데이터 패킷을 보낼 때 오류가 나도록 함

>![시뮬레이션 흐름](/image/simul_flow.png)

>* SelectiveRepeat이 구현되는 것을 보이기 위해 Console창에 출력

>* FSM 작성하여 해당 프로토콜의 어떻게 돌아가는지 이해를 도움

>* 송신자측(client) Finite State Machine
>![클라이언트 FSM](/image/fsm_client.png)

>* 수신자측(server) Finite State Machine
>![클라이언트 FSM](/image/fsm_server.png)


----
## 개발 관련 사항

>* 개발 언어 : Java

>* 개발 환경 : Eclipse

>* 담당분야 : 출력을 제외한 소켓 통신, SelectiveRepeat 알고리즘 구현

----
## 실행화면

>* Client

>![실행화면](/image/res1.png)

>* WINDOW_SIZE는 3으로 최초 전송이 3개까지 가능하다. 그 이후 0번 ACK를 받아 base값이 증가했을 때 WINDOW가 옮겨져 3번 패킷을 보낼 수 있다.

>![실행화면](/image/res2.png)

>* 3번 패킷을 보낼 때 오류를 가정해 엉뚱한 순서의 패킷을 보내었다. 그 결과로 4번 패킷과 5번 패킷은 ACK를 받았지만 3번 패킷의 경우 ACK를 받지 못하였다. 시간이 흐른 뒤 3번 패킷의 타이머가 동작해 3번 패킷을 재전송하고 ACK를 받는 모습이 보인다.


>![실행화면](/image/res3.png)

>* 그 후 WINDOW_SIZE만큼 다시 패킷을 보내고 순서대로 ACK를 받는 모습을 확인할 수 있다.

>* Server

>![실행화면](/image/res4.png)

>* 서버쪽 결과화면이다. 패킷을 받을경우 WINDOW 안의 패킷을 받으면 ACK를 보내고 색이 바바뀌는 것 알 수 있다.

>![실행화면](/image/res5.png)

>* 클라이언트측에서 3번 패킷을 보낼 때 데이터가 오류가 발생해 100번 패킷을 보낸다. Timeout이후 3번 패킷을 재전송하는 것을 받아 ACK를 보내주었다.

